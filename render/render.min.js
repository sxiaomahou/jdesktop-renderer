"use strict";var require$$0$1=require("electron");var require$$0=require("electron/renderer");function getDefaultExportFromCjs(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x["default"]:x}var enmu={INVOKE:{SOCKET:{OPEN_DB:"socket:initdb",DISCONNECT:"socket:disconnect"},USER:{INSERT:"user:insert"},CONVERSATION:{LIST:"conversation:list",REMOVE:"conversation:remove",CLEAR_UNREAD:"conversation:clearunread",GET_TOTAL_UNREAD:"conversation:totalunread",CLEAR_TOTAL_UNREAD:"conversation:cleartotalunread",UPSERT:"conversation:upsert",INSERT:"conversation:insert",UPDATE:"conversation:update",GETONE:"conversation:getone"},MESSAGE:{INSERT:"message:insert",UPDATE:"message:update",GETLIST:"message:getlist",UPSERT:"message:upsert",RECALL:"message:recall",CLEAR:"message:clear",READ:"message:read",GETONE:"message:getone"}},SENT_STATE:{SUCCESS:0,SENDING:1,FAILED:2}};var tools=function({ENUM,utils}){let{CONVERATION_TYPE}=ENUM;let isGroup=type=>{return utils.isEqual(CONVERATION_TYPE.GROUP,type)};let formatMsg=({message,senders,groups})=>{let{content="{}",senderId,conversationType,conversationId}=message;content=utils.parse(content);let sender=utils.filter(senders,user=>{return utils.isEqual(user.id,senderId)})[0]||{};let target={};if(isGroup(conversationType)){target=utils.filter(groups,group=>{return utils.isEqual(group.id,conversationId)})[0]||{}}else{target=utils.filter(senders,user=>{return utils.isEqual(user.id,conversationId)})[0]||{}}message=utils.extend(message,{conversationTitle:target.name,conversationPortrait:target.portrait,conversationExts:target.exts,content:content,sender:sender,sentTime:Number(message.sentTime)});return message};let formatMsgs=({messages,senders,groups})=>{let _messages=utils.map(messages,message=>{let msg=formatMsg({message:message,senders:senders,groups:groups});return msg});return _messages};let formatConversation=({conversation,users,groups})=>{if(utils.isEmpty(conversation)){return conversation}let{id,type,draft,unreadCount,isTop,isMute,updatedTime,latestMessageId,latestMentionMessageId,latestMessageName,latestMessageIsSender,latestMessageIsUpdated,latestMessageSentTime,latestMessageSenderId,latestMessageContent,latestMessageMessageIndex,latestMessageIsRead,latestUnreadCount,latestReadCount}=conversation;let sender=utils.filter(users,user=>{return utils.isEqual(user.id,latestMessageSenderId)})[0]||{id:latestMessageSenderId};let target={};if(isGroup(type)){target=utils.filter(groups,group=>{return utils.isEqual(group.id,id)})[0]||{id:id}}else{target=utils.filter(users,user=>{return utils.isEqual(user.id,id)})[0]||{id:id}}let _conversation={conversationId:id,conversationType:type,conversationPortrait:target.portrait,conversationTitle:target.name,conversationExts:target.exts,draft:draft||"",isTop:Boolean(isTop),isMute:Boolean(isMute),latestMentionMsg:{},latestMessage:{conversationId:id,conversationType:type,conversationPortrait:target.portrait,conversationTitle:target.name,conversationExts:target.exts,content:utils.parse(latestMessageContent),isRead:Boolean(latestMessageIsRead),isSender:Boolean(latestMessageIsSender),isUpdated:Boolean(latestMessageIsUpdated),messageId:latestMessageId,mentionInfo:{},messageIndex:latestMessageMessageIndex,name:latestMessageName,readCount:Number(latestReadCount||0),unreadCount:Number(latestUnreadCount||0),sentTime:Number(latestMessageSentTime),referMsg:{},sender:sender},updatedTime:Number(updatedTime)||0,unreadCount:unreadCount||0};return _conversation};let formatConversations=({conversations,users,groups})=>{let _converations=utils.map(conversations,conversation=>{let _converation=formatConversation({conversation:conversation,users:users,groups:groups});return _converation});return _converations};return{isGroup:isGroup,formatMsg:formatMsg,formatMsgs:formatMsgs,formatConversations:formatConversations,formatConversation:formatConversation}};const{ipcRenderer:ipcRenderer$2}=require$$0;const{INVOKE:INVOKE$2,SENT_STATE}=enmu;const Tools$1=tools;function Message$1(option,$socket){let{message:$message,io,ENUM,utils,MessageCacher,emitter,common,Storage}=option;let{SIGNAL_NAME,MESSAGE_TYPE,EVENT,FUNC_PARAM_CHECKER,MESSAGE_ORDER,FILE_TYPE,UPLOAD_TYPE,ErrorType,CONVERATION_TYPE,STORAGE}=ENUM;let messageCacher=MessageCacher();let tools=Tools$1({ENUM:ENUM,utils:utils});io.on(SIGNAL_NAME.CMD_RECEIVED,message=>{io.emit(SIGNAL_NAME.CMD_CONVERSATION_CHANGED,utils.clone(message));if(utils.isEqual(message.name,MESSAGE_TYPE.CLEAR_UNREAD)){return}if(utils.isEqual(message.name,MESSAGE_TYPE.RECALL)){let{content}=message;return ipcRenderer$2.invoke(INVOKE$2.MESSAGE.RECALL,{message:content,name:MESSAGE_TYPE.RECALL_INFO}).then(()=>{emitter.emit(EVENT.MESSAGE_RECALLED,message)})}if(utils.isEqual(message.name,MESSAGE_TYPE.MODIFY)){let{content:{content,messageId,sentTime}}=message;let str=utils.decodeBase64(content);let newContent=utils.parse(str);utils.extend(message,{content:newContent,messageId:messageId,sentTime:sentTime});return ipcRenderer$2.invoke(INVOKE$2.MESSAGE.UPDATE,{message:{messageId:messageId,content:newContent,isUpdated:true}}).then(()=>{emitter.emit(EVENT.MESSAGE_UPDATED,message)})}if(utils.isEqual(message.name,MESSAGE_TYPE.READ_MSG)||utils.isEqual(message.name,MESSAGE_TYPE.READ_GROUP_MSG)){let{conversationType,conversationId,content:{msgs}}=message;return ipcRenderer$2.invoke(INVOKE$2.MESSAGE.READ,{messages:msgs}).then(()=>{let notify={conversationType:conversationType,conversationId:conversationId,messages:msgs};emitter.emit(EVENT.MESSAGE_READ,notify)})}if(!messageCacher.isInclude(message)){let{conversationId,conversationType}=message;messageCacher.add({conversationId:conversationId,conversationType:conversationType},message);Storage.set(STORAGE.SYNC_CONVERSATION_TIME,{time:message.sentTime});ipcRenderer$2.invoke(INVOKE$2.MESSAGE.INSERT,{messages:[message]}).then(()=>{emitter.emit(EVENT.MESSAGE_RECEIVED,message)})}});let sendMessage=message=>{return utils.deferred((resolve,reject)=>{let error=common.check(io,message,FUNC_PARAM_CHECKER.SENDMSG);if(!utils.isEmpty(error)){return reject(error)}let sender=io.getCurrentUser();let data={...message,sender:sender,sentState:SENT_STATE.SENDING,isSender:true};return ipcRenderer$2.invoke(INVOKE$2.MESSAGE.INSERT,{messages:[data]}).then(({id})=>{return $message.sendMessage(message).then(msg=>{utils.extend(msg,{sentState:SENT_STATE.SUCCESS,id:id});ipcRenderer$2.invoke(INVOKE$2.MESSAGE.UPDATE,{message:{id:id,sentTime:String(msg.sentTime),sentState:SENT_STATE.SUCCESS,messageIndex:msg.messageIndex,messageId:msg.messageId}});Storage.set(STORAGE.SYNC_CONVERSATION_TIME,{time:msg.sentTime});io.emit(SIGNAL_NAME.CMD_CONVERSATION_CHANGED,msg);resolve(msg)},msg=>{ipcRenderer$2.invoke(INVOKE$2.MESSAGE.UPDATE,{message:{id:id,sentState:SENT_STATE.FAILED}});reject(msg)})})})};let getMessages=conversation=>{return utils.deferred((resolve,reject)=>{let isStatic=true;let error=common.check(io,conversation,FUNC_PARAM_CHECKER.GETMSGS,isStatic);if(!utils.isEmpty(error)){return reject(error)}if(!$socket.isOpenDB()){return reject(ErrorType.DATABASE_NOT_OPENED)}let params={time:conversation.time||0,order:conversation.order||MESSAGE_ORDER.FORWARD,count:conversation.count||20,names:conversation.names||[],conversationType:conversation.conversationType,conversationId:conversation.conversationId};ipcRenderer$2.invoke(INVOKE$2.MESSAGE.GETLIST,{conversation:params}).then(({messages,isFinished,groups,senders})=>{let isCon=utils.isContinuous(messages,"messageIndex");let len=messages.length;let isFetch=isFinished&&params.count>len;if(!isCon||isFetch){return $message.getMessages(conversation).then(result=>{ipcRenderer$2.invoke(INVOKE$2.MESSAGE.UPSERT,{messages:result.messages});resolve({isFinished:result.isFinished,messages:result.messages})},reject)}let _msgs=tools.formatMsgs({messages:messages,senders:senders,groups:groups});resolve({isFinished:isFinished,messages:_msgs})})})};let getMessagesByIds=params=>{return $message.getMessagesByIds(params)};let clearMessage=params=>{return utils.deferred((resolve,reject)=>{let error=common.check(io,params,FUNC_PARAM_CHECKER.CLEARMSG);if(!utils.isEmpty(error)){return reject(error)}$message.clearMessage(params).then(()=>{return ipcRenderer$2.invoke(INVOKE$2.MESSAGE.CLEAR,{params:params}).then(()=>{resolve()})},reject)})};let recallMessage=message=>{return utils.deferred((resolve,reject)=>{let error=common.check(io,message,FUNC_PARAM_CHECKER.RECALLMSG);if(!utils.isEmpty(error)){return reject(error)}$message.recallMessage(message).then(result=>{let{content}=result;ipcRenderer$2.invoke(INVOKE$2.MESSAGE.RECALL,{message:content,name:MESSAGE_TYPE.RECALL_INFO}).then(()=>{let msg={...result,name:MESSAGE_TYPE.RECALL};io.emit(SIGNAL_NAME.CMD_CONVERSATION_CHANGED,msg);return resolve(result)})},reject)})};let readMessage=messages=>{return utils.deferred((resolve,reject)=>{let error=common.check(io,messages,FUNC_PARAM_CHECKER.READMESSAGE);if(!utils.isEmpty(error)){return reject(error)}$message.readMessage(messages).then(()=>{ipcRenderer$2.invoke(INVOKE$2.MESSAGE.READ,{messages:messages}).then(()=>{resolve()})},reject)})};let getMessageReadDetails=message=>{return $message.getMessageReadDetails(message)};let updateMessage=message=>{return utils.deferred((resolve,reject)=>{let error=common.check(io,message,FUNC_PARAM_CHECKER.UPDATEMESSAGE);if(!utils.isEmpty(error)){return reject(error)}$message.updateMessage(message).then(msg=>{let params={messageId:message.messageId,content:message.content,isUpdated:true};return ipcRenderer$2.invoke(INVOKE$2.MESSAGE.UPDATE,{message:params}).then(()=>{io.emit(SIGNAL_NAME.CMD_CONVERSATION_CHANGED,msg);resolve(msg)})},reject)})};let deferredMessageContent=message=>{return utils.deferred((resolve,reject)=>{let isStatic=true;let error=common.check(io,message,FUNC_PARAM_CHECKER.MESSAGE_DEFERRED,isStatic);if(!utils.isEmpty(error)){return reject(error)}if(!$socket.isOpenDB()){return reject(ErrorType.DATABASE_NOT_OPENED)}return ipcRenderer$2.invoke(INVOKE$2.MESSAGE.GETONE,{message:message}).then(_msg=>{_msg=tools.formatMsg({message:_msg,senders:[],groups:[]});let{content}=message;_msg.content=utils.extend(_msg.content,content);let params={messageId:message.messageId,content:_msg.content};return ipcRenderer$2.invoke(INVOKE$2.MESSAGE.UPDATE,{message:params}).then(()=>{msg=utils.extend(msg,_msg);io.emit(SIGNAL_NAME.CMD_CONVERSATION_CHANGED,msg);resolve(msg)})})})};let getMentionMessages=conversation=>{return $message.getMentionMessages(conversation)};let getFileToken=params=>{return $message.getFileToken(params)};let sendFile=(option,message,callbacks={})=>{return utils.deferred((resolve,reject)=>{let error=common.check(io,message,FUNC_PARAM_CHECKER.SEND_FILE_MESSAGE);let{uploadType}=io.getConfig();if(utils.isEqual(uploadType,UPLOAD_TYPE.NONE)){error=ErrorType.UPLOAD_PLUGIN_ERROR}if(!utils.isEmpty(error)){return reject(error)}let{conversationType,conversationId,content,name}=message;let sender=io.getCurrentUser();let{file}=content;let size=file.size/1024;let _msg={conversationType:conversationType,conversationId:conversationId,name:name,content:{...content,name:file.name,type:file.type,size:size.toFixed(2),localPath:file.path},sentTime:Date.now(),sender:sender,sentState:SENT_STATE.SENDING,isSender:true};delete _msg.content.file;ipcRenderer$2.invoke(INVOKE$2.MESSAGE.INSERT,{messages:[_msg]}).then(({id})=>{$message._uploadFile(option,message,{onprogress:callbacks.onprogress,oncompleted:_message=>{$message.sendMessage(_message).then(msg=>{utils.extend(msg,{sentState:SENT_STATE.SUCCESS,id:id});ipcRenderer$2.invoke(INVOKE$2.MESSAGE.UPDATE,{message:{id:id,sentTime:String(msg.sentTime),sentState:SENT_STATE.SUCCESS,messageIndex:msg.messageIndex,messageId:msg.messageId}});io.emit(SIGNAL_NAME.CMD_CONVERSATION_CHANGED,msg);resolve(msg)},msg=>{ipcRenderer$2.invoke(INVOKE$2.MESSAGE.UPDATE,{message:{id:id,sentState:SENT_STATE.FAILED}});io.emit(SIGNAL_NAME.CMD_CONVERSATION_CHANGED,msg);reject(msg)})},onerror:callbacks.onerror})})})};let sendFileMessage=(message,callbacks={})=>{message=utils.extend(message,{name:MESSAGE_TYPE.FILE});let option={fileType:FILE_TYPE.FILE};return sendFile(option,message,callbacks)};let sendImageMessage=(message,callbacks={})=>{message=utils.extend(message,{name:MESSAGE_TYPE.IMAGE});let option={fileType:FILE_TYPE.IMAGE,scale:message.scale};return sendFile(option,message,callbacks)};let sendVoiceMessage=(message,callbacks={})=>{message=utils.extend(message,{name:MESSAGE_TYPE.VOICE});let option={fileType:FILE_TYPE.AUDIO};return sendFile(option,message,callbacks)};let sendVideoMessage=(message,callbacks={})=>{message=utils.extend(message,{name:MESSAGE_TYPE.VIDEO});let option={fileType:FILE_TYPE.VIDEO,scale:message.scale};return sendFile(option,message,callbacks)};let sendMergeMessage=params=>{return utils.deferred((resolve,reject)=>{let error=common.check(io,params,FUNC_PARAM_CHECKER.SEND_MERGE_MESSAGE);if(!utils.isEmpty(error)){return reject(error)}let{conversationType,conversationId,messages,labels,title}=params;if(messages.length>20){return reject(ErrorType.TRANSFER_MESSAGE_COUNT_EXCEED)}let mergeMsg={channelType:CONVERATION_TYPE.PRIVATE,targetId:""};messages=utils.map(messages,message=>{utils.extend(mergeMsg,{channelType:message.conversationType,targetId:message.conversationId});return{msgId:message.messageId,msgTime:message.sentTime,msgIndex:message.messageIndex}});let user=io.getCurrentUser();utils.extend(mergeMsg,{userId:user.id,msgs:messages});let msg={conversationId:conversationId,conversationType:conversationType,name:MESSAGE_TYPE.MERGE,mergeMsg:mergeMsg,content:{labels:labels,title:title}};return sendMessage(msg).then(resolve,reject)})};let getMergeMessages=params=>{return utils.deferred((resolve,reject)=>{let error=common.check(io,params,FUNC_PARAM_CHECKER.GET_MERGE_MESSAGES);if(!utils.isEmpty(error)){return reject(error)}return $message.getMergeMessages(params).then(resolve,reject)})};return{sendMessage:sendMessage,getMessages:getMessages,getMessagesByIds:getMessagesByIds,clearMessage:clearMessage,recallMessage:recallMessage,readMessage:readMessage,getMessageReadDetails:getMessageReadDetails,updateMessage:updateMessage,deferredMessageContent:deferredMessageContent,getMentionMessages:getMentionMessages,getFileToken:getFileToken,sendFileMessage:sendFileMessage,sendImageMessage:sendImageMessage,sendVoiceMessage:sendVoiceMessage,sendVideoMessage:sendVideoMessage,sendMergeMessage:sendMergeMessage,getMergeMessages:getMergeMessages}}var message=Message$1;const{ipcRenderer:ipcRenderer$1}=require$$0;const{INVOKE:INVOKE$1}=enmu;const Tools=tools;function Conversation$1(option,$socket){let{conversation:$conversation,io,ENUM,utils,MessageCacher,emitter,common}=option;let{SIGNAL_NAME,MESSAGE_TYPE,EVENT,FUNC_PARAM_CHECKER,CONVERSATION_ORDER,CONNECT_STATE,MENTION_TYPE,ErrorType}=ENUM;let tools=Tools({ENUM:ENUM,utils:utils});let conversationUtils=common.ConversationUtils();let UPDATE_CONVERSATION_TYPE={ONE:"one",MULTI_UNREADCOUNT:"multi_unreadcount"};io.on(SIGNAL_NAME.CMD_CONVERSATION_CHANGED,message=>{let{conversationType,conversationId}=message;if(utils.isInclude([MESSAGE_TYPE.READ_MSG,MESSAGE_TYPE.READ_GROUP_MSG],message.name)){return}if(utils.isEqual(message.name,MESSAGE_TYPE.RECALL)){let{content:{messageId}}=message;let conversation=conversationUtils.getPer({conversationId:conversationId,conversationType:conversationType});let{latestMessage}=conversation;latestMessage=latestMessage||{};let isNotify=utils.isEqual(latestMessage.messageId,messageId);let data={conversationId:conversationId,conversationType:conversationType,latestMessage:{name:MESSAGE_TYPE.RECALL_INFO,content:message.content}};updateConversation(data).then(()=>{if(isNotify){notify(message)}});return}if(utils.isEqual(message.name,MESSAGE_TYPE.CLEAR_UNREAD)){let{content,name,isSender}=message;let{conversations:msgs}=content;return updateConversation(content,UPDATE_CONVERSATION_TYPE.MULTI_UNREADCOUNT).then(()=>{utils.forEach(msgs,msg=>{utils.extend(msg,{name:name,isSender:isSender});notify(msg)})})}if(utils.isEqual(message.name,MESSAGE_TYPE.MODIFY)){let{content:{messageId,content}}=message;let conversation=conversationUtils.getPer({conversationId:conversationId,conversationType:conversationType});let latestMessage=conversation.latestMessage||{};let isNotify=utils.isEqual(latestMessage.messageId,messageId);let newContent={content:content};if(utils.isBase64(content)){let str=utils.decodeBase64(content);newContent=utils.parse(str)}let data={conversationId:conversationId,conversationType:conversationType,latestMessage:{isUpdated:true,content:newContent}};updateConversation(data).then(()=>{if(isNotify){notify(message)}});return}updateConversation({conversationId:conversationId,conversationType:conversationType,latestMessage:message}).then(()=>{notify(message)});function updateConversation(data,type){type=type||UPDATE_CONVERSATION_TYPE.ONE;return utils.deferred(resolve=>{let invoke=conversation=>{let{latestMessage}=data;if(latestMessage){data.updatedTime=latestMessage.sentTime;let msg=conversation.latestMessage;data.latestMessage=utils.extend(msg,latestMessage)}conversation=utils.extend(conversation,data);conversationUtils.update(conversation);let current=conversationUtils.getPer(message);if(utils.isEqual(type,UPDATE_CONVERSATION_TYPE.ONE)){ipcRenderer$1.invoke(INVOKE$1.CONVERSATION.UPDATE,{conversation:current}).then(resolve)}if(utils.isEqual(type,UPDATE_CONVERSATION_TYPE.MULTI_UNREADCOUNT)){ipcRenderer$1.invoke(INVOKE$1.CONVERSATION.CLEAR_UNREAD,data).then(resolve)}};let conversation=conversationUtils.getPer(message);if(utils.isEmpty(conversation)){return ipcRenderer$1.invoke(INVOKE$1.CONVERSATION.GETONE,{conversation:{conversationId:conversationId,conversationType:conversationType}}).then(result=>{let current=tools.formatConversation(result);if(utils.isEmpty(current)){current=createConversation(message)}invoke(current)})}invoke(conversation)})}function notify(msg){let conversation=conversationUtils.getPer(msg);let conversations=conversationUtils.get();emitter.emit(EVENT.CONVERSATION_CHANGED,{conversations:conversations,conversation:conversation})}});io.on(SIGNAL_NAME.CONN_CHANGED,({state})=>{if(utils.isEqual(state,CONNECT_STATE.DISCONNECTED)){conversationUtils.clear()}});io.on(SIGNAL_NAME.CMD_SYNC_CONVERSATIONS,({isFinished,conversations})=>{if(utils.isEmpty(conversations)){return emitter.emit(EVENT.CONVERSATION_SYNCED,{})}ipcRenderer$1.invoke(INVOKE$1.CONVERSATION.UPSERT,{conversations:conversations}).then(()=>{if(isFinished){emitter.emit(EVENT.CONVERSATION_SYNCED,{})}})});let getConversations=(params={})=>{return utils.deferred((resolve,reject)=>{if(!$socket.isOpenDB()){return reject(ErrorType.DATABASE_NOT_OPENED)}let option={count:params.count||50,order:params.order||CONVERSATION_ORDER.FORWARD,time:params.time||0};ipcRenderer$1.invoke(INVOKE$1.CONVERSATION.LIST,{option:option}).then(({conversations,groups,users})=>{let _conversations=tools.formatConversations({conversations:conversations,users:users,groups:groups});conversationUtils.add(_conversations);resolve({conversations:_conversations})})})};let removeConversation=conversations=>{return utils.deferred((resolve,reject)=>{let error=common.check(io,conversations,FUNC_PARAM_CHECKER.REMOVECONVERSATION);if(!utils.isEmpty(error)){return reject(error)}$conversation.removeConversation(conversations).then(()=>{let list=utils.isArray(conversations)?conversations:[conversations];ipcRenderer$1.invoke(INVOKE$1.CONVERSATION.REMOVE,{conversations:list}).then(()=>{utils.forEach(list,conversation=>{conversationUtils.remove(conversation)});resolve()})},reject)})};let clearUnreadcount=conversations=>{return utils.deferred((resolve,reject)=>{let error=common.check(io,conversations,FUNC_PARAM_CHECKER.CLEARUNREADCOUNT);if(!utils.isEmpty(error)){return reject(error)}$conversation.clearUnreadcount(conversations).then(()=>{ipcRenderer$1.invoke(INVOKE$1.CONVERSATION.CLEAR_UNREAD,{conversations:conversations}).then(resolve)},reject)})};let getTotalUnreadcount=()=>{return utils.deferred((resolve,reject)=>{if(!$socket.isOpenDB()){return reject(ErrorType.DATABASE_NOT_OPENED)}ipcRenderer$1.invoke(INVOKE$1.CONVERSATION.GET_TOTAL_UNREAD,{}).then(({total})=>{resolve({count:total})})})};let clearTotalUnreadcount=()=>{return utils.deferred((resolve,reject)=>{let error=common.check(io,{},{});if(!utils.isEmpty(error)){return reject(error)}$conversation.clearTotalUnreadcount().then(()=>{ipcRenderer$1.invoke(INVOKE$1.CONVERSATION.CLEAR_TOTAL_UNREAD,{}).then(resolve)},reject)})};let setDraft=conversation=>{return $conversation.setDraft(conversation)};let getDraft=conversation=>{return $conversation.getDraft(conversation)};let removeDraft=conversation=>{return $conversation.removeDraft(conversation)};function createConversation(message){let{conversationId,conversationType,conversationTitle,conversationPortrait,conversationExts,mentionInfo,messageId}=message;let $conversation={conversationId:conversationId,conversationType:conversationType,conversationTitle:conversationTitle,conversationPortrait:conversationPortrait,conversationExts:conversationExts,latestMessage:message,unreadCount:0,updatedTime:0};let latestMentionMsg={};if(mentionInfo){let{members,type}=mentionInfo;let user=io.getCurrentUser();let index=utils.find(members,member=>{return utils.isEqual(user.id,member.id)});if(index>-1||utils.isEqual(type,MENTION_TYPE.ALL)){latestMentionMsg={type:type,messageId:messageId,sender:message.sender}}utils.extend($conversation,{latestMentionMsg:latestMentionMsg})}return $conversation}return{getConversations:getConversations,removeConversation:removeConversation,clearUnreadcount:clearUnreadcount,getTotalUnreadcount:getTotalUnreadcount,clearTotalUnreadcount:clearTotalUnreadcount,setDraft:setDraft,getDraft:getDraft,removeDraft:removeDraft}}var conversation=Conversation$1;const{ipcRenderer}=require$$0;const{INVOKE}=enmu;function Socket$1(appkey,option){let{socket:$socket,io,common,ENUM,utils,emitter}=option;let{SIGNAL_NAME,EVENT,CONNECT_STATE,ErrorType,FUNC_PARAM_CHECKER}=ENUM;let $isOpenDatabase=false;io.on(SIGNAL_NAME.CONN_CHANGED,data=>{emitter.emit(EVENT.STATE_CHANGED,data)});let connect=user=>{return utils.deferred((resolve,reject)=>{let error=common.check(io,user,FUNC_PARAM_CHECKER.CONNECT,true);if(!utils.isEmpty(error)){return reject(error)}$isOpenDatabase=true;ipcRenderer.invoke(INVOKE.SOCKET.OPEN_DB,{appkey:appkey,user:user}).then(result=>{emitter.emit(EVENT.STATE_CHANGED,{state:CONNECT_STATE.DB_OPENED});return $socket.connect(user).then(_user=>{ipcRenderer.invoke(INVOKE.USER.INSERT,{user:_user});resolve(_user)},reject)})})};let disconnect=()=>{$isOpenDatabase=false;return ipcRenderer.invoke(INVOKE.SOCKET.DISCONNECT,{}).then(()=>{emitter.emit(EVENT.STATE_CHANGED,{state:CONNECT_STATE.CLOSED});return $socket.disconnect()})};let isConnected=()=>{return $socket.isConnected()};let getCurrentUser=()=>{return $socket.getCurrentUser()};let isOpenDB=()=>{return $isOpenDatabase};return{connect:connect,disconnect:disconnect,isConnected:isConnected,getCurrentUser:getCurrentUser,isOpenDB:isOpenDB}}var socket=Socket$1;const{contextBridge}=require$$0$1;const Message=message;const Conversation=conversation;const Socket=socket;function next(){let init=(appkey,option)=>{let socket=Socket(appkey,option);return{conversation:Conversation(option,socket),message:Message(option,socket),socket:socket}};contextBridge.exposeInMainWorld("JGChatPCClient",{init:init})}var render=next();var render$1=getDefaultExportFromCjs(render);module.exports=render$1;