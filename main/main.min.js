"use strict";var require$$0$1=require("electron/main");var require$$0=require("sqlite3");var require$$1=require("electron");var require$$2=require("fs");var require$$3=require("path");function getDefaultExportFromCjs(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x["default"]:x}var enmu={INVOKE:{SOCKET:{OPEN_DB:"socket:initdb",DISCONNECT:"socket:disconnect"},USER:{INSERT:"user:insert"},CONVERSATION:{LIST:"conversation:list",REMOVE:"conversation:remove",CLEAR_UNREAD:"conversation:clearunread",GET_TOTAL_UNREAD:"conversation:totalunread",CLEAR_TOTAL_UNREAD:"conversation:cleartotalunread",UPSERT:"conversation:upsert",INSERT:"conversation:insert",UPDATE:"conversation:update",GETONE:"conversation:getone"},MESSAGE:{INSERT:"message:insert",UPDATE:"message:update",GETLIST:"message:getlist",UPSERT:"message:upsert",RECALL:"message:recall",CLEAR:"message:clear",READ:"message:read",GETONE:"message:getone"}},SENT_STATE:{SUCCESS:0,SENDING:1,FAILED:2}};const sqlite3=require$$0.verbose();const{app:app$1}=require$$1;const fs=require$$2;const path=require$$3;function initDB(db){let SQL={MESSAGE:`CREATE TABLE IF NOT EXISTS messages (
      id TEXT(64), 
      conversationType INT, 
      conversationId TEXT(64),
      name TEXT(64),
      content TEXT,
      messageId TEXT(64),
      isSender INT,
      isUpdated INT,
      isRead INT,
      sentState INT,
      sentTime TEXT,
      mergeMsg TEXT,
      readCount INT,
      unreadCount INT,
      senderId TEXT(64),
      messageIndex INT
    );`,MESSAGE_INDEX:"CREATE UNIQUE INDEX IF NOT EXISTS idx_message ON messages(messageId);",CONVERSATION:`
      CREATE TABLE IF NOT EXISTS conversations (
        id TEXT(64), 
        type INT,
        draft TEXT,
        unreadCount INT,
        isTop INT,
        isMute INT,
        updatedTime TEXT,
        latestMessageId TEXT(64),
        latestMentionMessageId TEXT(64),
        latestMessageName TEXT(64),
        latestMessageIsSender INT,
        latestMessageIsRead INT,
        latestMessageIsUpdated INT,
        latestMessageSentTime TEXT,
        latestMessageSenderId TEXT(64),
        latestUnreadCount INT,
        latestReadCount TEXT,
        latestMessageContent TEXT,
        latestMessageMessageIndex TEXT
      );
    `,CONVERSATION_INDEX:"CREATE UNIQUE INDEX IF NOT EXISTS idx_conversation ON conversations(type, id);",GROUP:`
      CREATE TABLE IF NOT EXISTS users (
        id TEXT, 
        name TEXT,
        portrait TEXT,
        exts TEXT,
        updatedTime TEXT
      );
    `,USER:`
      CREATE TABLE IF NOT EXISTS groups (
        id TEXT, 
        name TEXT,
        portrait TEXT,
        exts TEXT,
        updatedTime TEXT
      );
    `};db.serialize(()=>{db.run(SQL.MESSAGE);db.run(SQL.MESSAGE_INDEX);db.run(SQL.CONVERSATION);db.run(SQL.CONVERSATION_INDEX);db.run(SQL.GROUP);db.run(SQL.USER)})}function create({appkey,userId,dbpath}){dbpath=dbpath||app$1.getPath("appData");let dir=path.join(dbpath,app$1.getName());if(!fs.existsSync(dir)){fs.mkdirSync(dir)}let name=`${appkey}_${userId}.db`;let url=path.join(dir,name);let db=new sqlite3.Database(url);initDB(db);return db}function init$1(option){let db=create(option);return db}var database={init:init$1};const noop=()=>{};const isObject=obj=>{return Object.prototype.toString.call(obj)==="[object Object]"};const isArray=arr=>{return Object.prototype.toString.call(arr)==="[object Array]"};const isFunction=arr=>{return Object.prototype.toString.call(arr)==="[object Function]"};const isString=str=>{return Object.prototype.toString.call(str)==="[object String]"};const isBoolean=str=>{return Object.prototype.toString.call(str)==="[object Boolean]"};const isUndefined=str=>{return Object.prototype.toString.call(str)==="[object Undefined]"};const isNull=str=>{return Object.prototype.toString.call(str)==="[object Null]"};const isNumber=str=>{return Object.prototype.toString.call(str)==="[object Number]"};const stringify=obj=>{return JSON.stringify(obj)};const parse=str=>{let obj={};try{obj=JSON.parse(str)}catch(e){obj=str}return obj};const forEach=(obj,callback)=>{callback=callback||noop;let loopObj=()=>{for(var key in obj){callback(obj[key],key,obj)}};var loopArr=()=>{for(var i=0,len=obj.length;i<len;i++){callback(obj[i],i,obj)}};if(isObject(obj)){loopObj()}if(isArray(obj)){loopArr()}};const isEmpty=obj=>{let result=true;if(isObject(obj)){forEach(obj,()=>{result=false})}if(isString(obj)||isArray(obj)){result=obj.length===0}if(isNumber(obj)){result=obj===0}return result};const rename=(origin,newNames)=>{var isObj=isObject(origin);if(isObj){origin=[origin]}origin=parse(stringify(origin));var updateProperty=function(val,key,obj){delete obj[key];key=newNames[key];obj[key]=val};forEach(origin,item=>{forEach(item,(val,key,obj)=>{var isRename=key in newNames;(isRename?updateProperty:noop)(val,key,obj)})});return isObject?origin[0]:origin};const extend=(destination,sources)=>{sources=isArray(sources)?sources:[sources];forEach(sources,source=>{for(let key in source){let value=source[key];if(!isUndefined(value)){destination[key]=value}}});return destination};const Defer=Promise;const deferred=callback=>{return new Defer(callback)};const templateFormat=(tpl,data,regexp)=>{if(!isArray(data)){data=[data]}let ret=[];let replaceAction=object=>{return tpl.replace(regexp||/\\?\{([^}]+)\}/g,(match,name)=>{if(match.charAt(0)==="\\")return match.slice(1);return object[name]!==undefined?object[name]:"{"+name+"}"})};for(let i=0,j=data.length;i<j;i++){ret.push(replaceAction(data[i]))}return ret.join("")};const isContain=(str,keyword)=>{return str.indexOf(keyword)>-1};const isEqual=(source,target)=>{return source===target};const Cache$2=cache=>{if(!isObject(cache)){cache={}}let set=(key,value)=>{cache[key]=value};let get=key=>{return cache[key]};let remove=key=>{delete cache[key]};let getKeys=()=>{let keys=[];for(let key in cache){keys.push(key)}return keys};let clear=()=>{cache={}};return{set:set,get:get,remove:remove,getKeys:getKeys,clear:clear}};const request=(url,option)=>{return deferred((resolve,reject)=>{requestNormal(url,option,{success:resolve,fail:reject})})};const requestNormal=(url,option,callback)=>{option=option||{};let xhr=new XMLHttpRequest;let method=option.method||"GET";xhr.open(method,url,true);let headers=option.headers||{};forEach(headers,(header,name)=>{xhr.setRequestHeader(name,header)});let body=option.body||{};let isSuccess=()=>{return/^(200|202)$/.test(xhr.status)};let timeout=option.timeout;if(timeout){xhr.timeout=timeout}xhr.onreadystatechange=function(){if(isEqual(xhr.readyState,4)){let{responseText}=xhr;responseText=responseText||"{}";let result=JSON.parse(responseText);if(isSuccess()){callback.success(result,xhr)}else{let{status}=xhr;let error={status:status,result:result};callback.fail(error)}}};xhr.onerror=error=>{callback.fail(error)};xhr.send(body);return xhr};const map=(arrs,callback)=>{return arrs.map(callback)};const filter=(arrs,callback)=>{return arrs.filter(callback)};const uniq=(arrs,callback)=>{let newData=[],tempData={};arrs.forEach(target=>{let temp=callback(target);tempData[temp.key]=temp.value});forEach(tempData,val=>{newData.push(val)});return newData};const some=(arrs,callback)=>{return arrs.some(callback)};const toJSON=value=>{return JSON.stringify(value)};const toArray=obj=>{let arrs=[];forEach(obj,(v,k)=>{arrs.push([k,v])});return arrs};const isInclude=(str,match)=>{return str.indexOf(match)>-1};const clone=source=>{return JSON.parse(JSON.stringify(source))};function Index(){let index=0;this.add=()=>{index+=1};this.get=()=>{return index};this.reset=()=>{index=0}}function Observer(){let observers=[];this.add=(observer,force)=>{if(isFunction(observer)){if(force){return observers=[observer]}observers.push(observer)}};this.remove=observer=>{observers=filter(observers,_observer=>{return _observer!==observer})};this.emit=data=>{forEach(observers,observer=>{observer(data)})}}function Prosumer(){let data=[],isConsuming=false;this.produce=res=>{data.push(res)};this.consume=(callback,finished)=>{if(isConsuming){return}isConsuming=true;let next=()=>{let res=data.shift();if(isUndefined(res)){isConsuming=false;finished&&finished();return}callback(res,next)};next()};this.isExeuting=function(){return isConsuming}}const getBrowser=()=>{let userAgent=navigator.userAgent;let name="",version="";if(/(Msie|Firefox|Opera|Chrome|Netscape)\D+(\d[\d.]*)/.test(userAgent)){name=RegExp.$1;version=RegExp.$2}if(/Version\D+(\d[\d.]*).*Safari/.test(userAgent)){name="Safari";version=RegExp.$1}return{name:name,version:version}};const getUUID=()=>{return"xxxx-xxxx-xxxx".replace(/[xy]/g,function(c){let r=Math.random()*16|0,v=c=="x"?r:r&3|8;return v.toString(16)})};const getProtocol=(url="")=>{let http=location.protocol;if(isEqual(http,"file:")){http="http:"}if(isInclude(url,"https://")){http="https:"}let wsMap={"http:":"ws:","https:":"wss:"};let ws=wsMap[http];return{http:http,ws:ws}};const sort=(arrs,callback)=>{const len=arrs.length;if(len<2){return arrs}for(let i=0;i<len-1;i++){for(let j=i+1;j<len;j++){if(callback(arrs[j],arrs[i])){[arrs[i],arrs[j]]=[arrs[j],arrs[i]]}}}return arrs};const quickSort=(arr,callback)=>{if(arr.length<2){return arr}let pivot=arr[0];let left=[];let right=[];for(let i=1;i<arr.length;i++){if(callback(arr[i],pivot)){left.push(arr[i])}else{right.push(arr[i])}}return[...quickSort(left,callback),pivot,...quickSort(right,callback)]};const find=(arrs,callback)=>{let len=arrs.length;let index=-1;for(let i=0;i<len;i++){let item=arrs[i];if(callback(item)){index=i;break}}return index};const toObject=arrs=>{let objs={};forEach(arrs,(item={})=>{let key=item.key;let value=item.value;objs[key]=value});return objs};const decodeBase64=function(input){let _keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";let output="";let chr1,chr2,chr3;let enc1,enc2,enc3,enc4;let i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");while(i<input.length){enc1=_keyStr.indexOf(input.charAt(i++));enc2=_keyStr.indexOf(input.charAt(i++));enc3=_keyStr.indexOf(input.charAt(i++));enc4=_keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output+=String.fromCharCode(chr1);if(enc3!==64){output+=String.fromCharCode(chr2)}if(enc4!==64){output+=String.fromCharCode(chr3)}}return output};function formatTime(time,fmt="yyyy-MM-dd hh:mm:ss"){let date=new Date(time);var o={"M+":date.getMonth()+1,"d+":date.getDate(),"h+":date.getHours(),"m+":date.getMinutes(),"s+":date.getSeconds(),"q+":Math.floor((date.getMonth()+3)/3),S:date.getMilliseconds()};if(/(y+)/.test(fmt))fmt=fmt.replace(RegExp.$1,(date.getFullYear()+"").substr(4-RegExp.$1.length));for(var k in o)if(new RegExp("("+k+")").test(fmt))fmt=fmt.replace(RegExp.$1,RegExp.$1.length==1?o[k]:("00"+o[k]).substr((""+o[k]).length));return fmt}function duplicate(arrs,callback){let objs={};forEach(arrs,item=>{let key=callback(item);objs[key]=item});let list=[];forEach(objs,v=>{list.push(v)});return list}const isBase64=str=>{var regex=/^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$/;return regex.test(str)};var utils$6={Prosumer:Prosumer,Observer:Observer,isUndefined:isUndefined,isBoolean:isBoolean,isString:isString,isObject:isObject,isArray:isArray,isFunction:isFunction,stringify:stringify,parse:parse,rename:rename,extend:extend,clone:clone,deferred:deferred,Defer:Defer,forEach:forEach,templateFormat:templateFormat,isContain:isContain,noop:noop,Cache:Cache$2,request:request,map:map,filter:filter,uniq:uniq,some:some,isEqual:isEqual,isEmpty:isEmpty,toJSON:toJSON,isInclude:isInclude,isNull:isNull,isNumber:isNumber,toArray:toArray,Index:Index,getBrowser:getBrowser,getUUID:getUUID,requestNormal:requestNormal,getProtocol:getProtocol,sort:sort,find:find,quickSort:quickSort,toObject:toObject,decodeBase64:decodeBase64,formatTime:formatTime,duplicate:duplicate,isBase64:isBase64};var cache=function(){let caches={};let set=(key,value)=>{caches[key]=value};let get=key=>{return caches[key]||{}};let remove=key=>{delete caches[key]};let clear=()=>{caches={}};return{set:set,get:get,remove:remove,clear:clear}};const utils$5=utils$6;function output(tag,name,content,args){if(utils$5.isObject(content)){content=utils$5.toJSON(content)}if(utils$5.isObject(args)){args=utils$5.toJSON(args)}let time=utils$5.formatTime(Date.now());console.log(`${tag} ${time} ${name}`,content,args)}var logger={log:(name,content="",args="")=>{output("JG:LOG",name,content,args)},error:(name,content="",args="")=>{output("JG:ERROR",name,content,args)}};const utils$4=utils$6;const Cache$1=cache;const Logger$3=logger;function User$3(DB){let cacher=Cache$1();let insert=user=>{cacher.set(user.id,user);let sql=`INSERT INTO users(
        id,
        name,
        portrait,
        updatedTime,
        exts
      )
      VALUES(
        $id,
        $name,
        $portrait,
        $updatedTime,
        $exts
      );`;return new Promise(resolve=>{DB.run(sql,{$id:user.id,$name:user.name,$portrait:user.portrait,$updatedTime:String(user.updatedTime),$exts:utils$4.toJSON(user.exts)},err=>{if(err){Logger$3.error("User insert",err.message,user)}resolve()})})};let update=user=>{cacher.set(user.id,user);let sql="UPDATE users SET name = $name, portrait = $portrait, updatedTime = $updatedTime, exts = $exts WHERE id = $id";return new Promise(resolve=>{DB.run(sql,{$id:user.id,$name:user.name,$portrait:user.portrait,$updatedTime:String(user.updatedTime),$exts:utils$4.toJSON(user.exts)},err=>{if(err){Logger$3.error("User update",err.message,user)}resolve()})})};let get=user=>{let users=utils$4.isArray(user)?user:[user];let userIds=utils$4.map(users,user=>{return user.id});let sql=`SELECT * FROM users WHERE id in ('${userIds.join("','")}');`;return new Promise(resolve=>{let cacherUsers=[];utils$4.forEach(userIds,userId=>{let _user=cacher.get(userId);if(!utils$4.isEmpty(_user)){cacherUsers.push(_user)}});if(utils$4.isEqual(cacherUsers.length,userIds.length)){let _user=utils$4.isArray(user)?cacherUsers:cacherUsers[0];return resolve(_user)}DB.all(sql,{},function(err,rows){if(err){Logger$3.error("User get",err.message,user)}utils$4.forEach(rows,row=>{let{exts}=row;row.exts=utils$4.parse(exts);cacher.set(row.id,row)});let _user=utils$4.isArray(user)?rows:rows[0];resolve(_user)})})};let upsert=user=>{return get(user).then(_user=>{if(utils$4.isEmpty(_user)){return insert(user)}if(user.updatedTime>_user.updatedTime){return update(user)}return user})};let remove=user=>{let sql="DELETE FROM users WHERE id = $id;";return new Promise(resolve=>{DB.run(sql,{$id:user.id},err=>{if(err){Logger$3.error("User remove",err.message,user)}resolve()})})};let clearCacher=()=>{cacher.clear()};return{upsert:upsert,remove:remove,get:get,insert:insert,update:update,clearCacher:clearCacher}}var user=User$3;const utils$3=utils$6;const Cache=cache;const Logger$2=logger;function Group$2(DB){let cacher=Cache();let insert=group=>{cacher.set(group.id,group);let sql="INSERT INTO groups(id, name, portrait, updatedTime, exts)VALUES($id, $name, $portrait, $updatedTime, $exts);";return new Promise(resolve=>{DB.run(sql,{$id:group.id,$name:group.name,$portrait:group.portrait,$updatedTime:String(group.updatedTime),$exts:utils$3.toJSON(group.exts)},err=>{if(err){Logger$2.error("Group insert",err.message,group)}resolve()})})};let update=group=>{cacher.set(group.id,group);let sql="UPDATE groups SET name = $name, portrait = $portrait, updatedTime = $updatedTime, exts = $exts WHERE id = $id";return new Promise(resolve=>{DB.run(sql,{$id:group.id,$name:group.name,$portrait:group.portrait,$updatedTime:String(group.updatedTime),$exts:utils$3.toJSON(group.exts)},err=>{if(err){Logger$2.error("Group update",err.message,group)}resolve()})})};let get=group=>{let groups=utils$3.isArray(group)?group:[group];let groupIds=utils$3.map(groups,group=>{return group.id});let sql=`SELECT * FROM groups WHERE id in ('${groupIds.join("','")}');`;return new Promise(resolve=>{let cacherGroups=[];utils$3.forEach(groupIds,groupId=>{let _group=cacher.get(groupId);if(!utils$3.isEmpty(_group)){cacherGroups.push(_group)}});if(utils$3.isEqual(cacherGroups.length,groupIds.length)){let _group=utils$3.isArray(group)?cacherGroups:cacherGroups[0];return resolve(_group)}DB.all(sql,{},function(err,rows){if(err){Logger$2.error("Group get",err.message,group)}utils$3.forEach(rows,row=>{let{exts}=row;row.exts=utils$3.parse(exts);cacher.set(row.id,row)});let _group=utils$3.isArray(group)?rows:rows[0];resolve(_group)})})};let upsert=group=>{return get(group).then(_group=>{if(utils$3.isEmpty(_group)){return insert(group)}if(group.updatedTime>_group.updatedTime){return update(group)}return group})};let remove=group=>{let sql="DELETE FROM groups WHERE id = $id;";return new Promise(resolve=>{DB.run(sql,{$id:group.id},err=>{if(err){Logger$2.error("Group remove",err.message,group)}resolve()})})};let clearCacher=()=>{cacher.clear()};return{upsert:upsert,remove:remove,get:get,insert:insert,update:update,clearCacher:clearCacher}}var group=Group$2;var _enum={CONVERSATION_TYPE:{PRIVATE:1,GROUP:2,CHATROOM:3,SYSTEM:4},MESSAGE_ORDER:{FORWARD:0,BACKWARD:1},CONVERSATION_ORDER:{FORWARD:0,BACKWARD:1}};const utils$2=utils$6;const{CONVERSATION_TYPE:CONVERSATION_TYPE$2}=_enum;function formatUpdateSQL(objs,conditions){let cols=[];let wheres=[];let data={};utils$2.forEach(objs,(v,k)=>{if(!utils$2.isInclude(conditions,k)){cols.push(`${k} = $${k}`)}data[`$${k}`]=utils$2.isObject(v)?utils$2.stringify(v):v});utils$2.forEach(conditions,k=>{wheres.push(`${k} = $${k}`)});return{cols:cols.join(","),wheres:wheres.join(" and "),data:data}}function formatInsertSQL(objs){let cols=[];let holders=[];let data={};utils$2.forEach(objs,(v,k)=>{cols.push(`${k}`);holders.push(`$${k}`);data[`$${k}`]=utils$2.isObject(v)?utils$2.stringify(v):v});return{cols:cols.join(","),holders:holders.join(","),data:data}}function formatWhereSQL(conditions){let wheres=[];utils$2.forEach(conditions,(v,k)=>{if(utils$2.isArray(v)){wheres.push(`${k} in (${v.join(",")})`)}else{wheres.push(`${k} = $${k}`)}});return wheres.join(" and ")}function isGroup(type){return utils$2.isEqual(CONVERSATION_TYPE$2.GROUP,type)}function formatConversation(conversation){let{conversationId,conversationType,draft,unreadCount,isTop,isMute,updatedTime,latestMessage,latestMentionMsg}=conversation;latestMentionMsg=latestMentionMsg||{};latestMessage=latestMessage||{};if(updatedTime){updatedTime=String(updatedTime)}let sentTime=latestMessage.sentTime;if(sentTime){sentTime=String(latestMessage.sentTime)}let sender=latestMessage.sender||{};let _converation={id:conversationId,type:conversationType,draft:draft,unreadCount:unreadCount,isTop:isTop,isMute:isMute,updatedTime:updatedTime,latestMessageId:latestMessage.messageId,latestMentionMessageId:latestMentionMsg.messageId,latestMessageName:latestMessage.name,latestMessageIsSender:latestMessage.isSender,latestMessageIsUpdated:latestMessage.isUpdated,latestMessageSentTime:sentTime,latestMessageSenderId:sender.id,latestMessageContent:utils$2.stringify(latestMessage.content),latestMessageMessageIndex:latestMessage.messageIndex};return utils$2.clone(_converation)}var common$2={formatUpdateSQL:formatUpdateSQL,formatWhereSQL:formatWhereSQL,formatInsertSQL:formatInsertSQL,isGroup:isGroup,formatConversation:formatConversation};const User$2=user;const Group$1=group;const utils$1=utils$6;const Logger$1=logger;const common$1=common$2;const{CONVERSATION_TYPE:CONVERSATION_TYPE$1,CONVERSATION_ORDER}=_enum;function Conversation$1(DB){let $user=User$2(DB);let $group=Group$1(DB);let getList=({option})=>{let{count,order,time}=option;let symbol="<";let direction="ASC";let _time=utils$1.isEqual(time,0)?Date.now():time;if(utils$1.isEqual(CONVERSATION_ORDER.FORWARD,order)){symbol=">";_time=time;direction="DESC"}let wheres=[`updatedTime ${symbol} ${_time}`];let sql=`SELECT * FROM conversations WHERE ${wheres.join(" AND ")} ORDER BY updatedTime ${direction} LIMIT ${count};`;return utils$1.deferred((resolve,reject)=>{DB.all(sql,[],(err,_conversations)=>{if(err){Logger$1.error("Conversation getList",err.message,{sql:sql})}let conversations=_conversations,groups=[],users=[];let _groups=[],_users=[];utils$1.forEach(_conversations,conversation=>{let{type,id}=conversation;if(common$1.isGroup(type)){_groups.push({id:id})}else{_users.push({id:id})}_users.push({id:conversation.latestMessageSenderId})});_users=utils$1.duplicate(_users,user=>{return user.id});let p1=$user.get(_users).then(result=>{users=result;return result});let p2=$group.get(_groups).then(result=>{groups=result;return result});Promise.all([p1,p2]).then(()=>{resolve({conversations:conversations,groups:groups,users:users})})})})};let insert=({conversations})=>{return utils$1.deferred(resolve=>{utils$1.forEach(conversations,async conversation=>{let _conversation=common$1.formatConversation(conversation);let params=common$1.formatInsertSQL(_conversation);let sql=`INSERT INTO conversations(${params.cols}) VALUES(${params.holders});`;await DB.run(sql,params.data,err=>{if(err){Logger$1.error("Conversation insert",err.message,conversation)}});let{conversationType,conversationId,latestMessage}=conversation;let{conversationTitle,conversationExts,conversationPortrait,conversationUpdatedTime,sender}=latestMessage;let target={id:conversationId,name:conversationTitle,portrait:conversationPortrait,exts:conversationExts,updatedTime:conversationUpdatedTime};if(common$1.isGroup(conversationType)){await $group.upsert(target)}else{await $user.upsert(target)}if(sender){await $user.upsert(sender)}});resolve()})};let upsert=({conversations})=>{let wheres=[];utils$1.forEach(conversations,({conversationType,conversationId})=>{wheres.push(`id = '${conversationId}' AND type = ${conversationType}`)});let sql=`DELETE FROM conversations WHERE ${wheres.join(" OR ")}`;DB.serialize(()=>{DB.run(sql);insert({conversations:conversations})})};let update=({conversation})=>{let _converation=common$1.formatConversation(conversation);let params=common$1.formatUpdateSQL(_converation,["id","type"]);let sql=`UPDATE conversations SET ${params.cols} WHERE ${params.wheres};`;return utils$1.deferred((resolve,reject)=>{DB.run(sql,params.data,err=>{if(err){Logger$1.error("Conversation update",err.message,{message:message,sql:sql,data:params.data})}resolve()})})};let get=({conversation})=>{let{conversationId,conversationType}=conversation;let sql=`SELECT * FROM conversations WHERE id = '${conversationId}' AND type = '${conversationType}';`;return utils$1.deferred((resolve,reject)=>{DB.get(sql,{},(err,row)=>{if(err){Logger$1.error("Conversation get",err.message,{sql:sql})}row=row||{id:conversationId,type:conversationType};let users=[],groups=[];let{latestMessageSenderId=""}=row;let _users=[{id:latestMessageSenderId}],_groups=[];let target={id:conversationId};if(common$1.isGroup(conversationType)){_groups.push(target)}else{_users.push(target)}let p1=$user.get(_users).then(list=>{users=list;return list});let p2=$group.get(_groups).then(list=>{groups=list;return list});Promise.all([p1,p2]).then(()=>{resolve({conversation:row,groups:groups,users:users})})})})};let remove=({conversations})=>{let cWheres=[],mWheres=[];utils$1.forEach(conversations,conversation=>{let{conversationType,conversationId}=conversation;cWheres.push(`id = '${conversationId}' AND type = ${conversationType}`);mWheres.push(`conversationId = '${conversationId}' AND conversationType = ${conversationType}`)});let cSQL=`DELETE FROM conversations WHERE ${cWheres.join(" OR ")}`;let mSQL=`DELETE FROM messages WHERE ${mWheres.join(" OR ")}`;return utils$1.deferred((resolve,reject)=>{DB.serialize(()=>{let p1=utils$1.deferred(_resolve=>{DB.run(cSQL,{},err=>{if(err){Logger$1.error("Conversation remove",err.message,{sql:cSQL})}});_resolve()});let p2=utils$1.deferred(_resolve=>{DB.run(mSQL,{},err=>{if(err){Logger$1.error("Conversation remove msgs",err.message,{sql:mSQL})}});_resolve()});Promise.all([p1,p2]).then(resolve)})})};let clearUnread=({conversations})=>{conversations=utils$1.isArray(conversations)?conversations:[conversations];return utils$1.deferred(resolve=>{let promises=[];utils$1.forEach(conversations,conversation=>{conversation=utils$1.extend(conversation,{unreadCount:0});let p=update({conversation:conversation});promises.push(p)});Promise.all(promises).then(resolve)})};let getTotalUnread=()=>{let sql=`SELECT SUM(unreadCount) as total FROM conversations;`;return utils$1.deferred(resolve=>{DB.get(sql,{},(err,row)=>{if(err){Logger$1.error("Conversation getTotalUnread",err.message,{sql:sql})}row=row||{total:0};resolve(row)})})};let clearTotalUnread=()=>{let sql=`UPDATE conversations set unreadCount = 0;`;return utils$1.deferred(resolve=>{DB.run(sql,{},err=>{if(err){Logger$1.error("Conversation clearTotalUnread",err.message,{sql:sql})}resolve()})})};return{getList:getList,upsert:upsert,insert:insert,update:update,get:get,remove:remove,clearUnread:clearUnread,getTotalUnread:getTotalUnread,clearTotalUnread:clearTotalUnread}}var conversation=Conversation$1;const User$1=user;const Group=group;const utils=utils$6;const Logger=logger;const common=common$2;const{CONVERSATION_TYPE,MESSAGE_ORDER}=_enum;function Message$1(DB){let $user=User$1(DB);let $group=Group(DB);let insert=({messages})=>{let sql=`
      INSERT INTO messages(
        id,
        conversationType,
        conversationId,
        name,
        content,
        messageId,
        isSender,
        isUpdated,
        isRead,
        sentTime,
        readCount,
        unreadCount,
        senderId,
        messageIndex
      ) VALUES(
        $id,
        $conversationType,
        $conversationId,
        $name,
        $content,
        $messageId,
        $isSender,
        $isUpdated,
        $isRead,
        $sentTime,
        $readCount,
        $unreadCount,
        $senderId,
        $messageIndex
      );
    `;return new Promise(resolve=>{let ids=[];messages.forEach(async message=>{let{conversationType,conversationPortrait,conversationTitle,conversationUpdatedTime,conversationId,conversationExts,sender,id}=message;id=id||utils.getUUID();ids.push(id);await DB.run(sql,{$id:id,$conversationType:conversationType,$conversationId:conversationId,$name:message.name,$content:JSON.stringify(message.content),$messageId:message.messageId||id,$isSender:Number(message.isSender||0),$isUpdated:Number(message.isUpdated||0),$isRead:Number(message.isRead||0),$sentTime:String(message.sentTime||Date.now()),$readCount:message.readCount||0,$unreadCount:message.unreadCount||0,$senderId:sender.id,$messageIndex:message.messageIndex||""},err=>{if(err){Logger.error("Message insert",err.message,message)}});let info={name:conversationTitle,updatedTime:conversationUpdatedTime,id:conversationId,portrait:conversationPortrait,exts:conversationExts};await $user.upsert(sender);if(utils.isEqual(CONVERSATION_TYPE.PRIVATE,conversationType)){await $user.upsert(info)}if(utils.isEqual(CONVERSATION_TYPE.GROUP,conversationType)){await $group.upsert(info)}});resolve({id:ids[0]})})};let update=({message})=>{let params=common.formatUpdateSQL(message,["id"]);let sql=`UPDATE messages SET ${params.cols} WHERE ${params.wheres} OR messageId = '${message.messageId}';`;let cSQL=`UPDATE conversations SET latestMessageIsUpdated = 1 WHERE latestMessageId = '${message.messageId}';`;return utils.deferred((resolve,reject)=>{DB.run(cSQL,{},err=>{if(err){Logger.error("Message update: conversations",err.message,{sql:cSQL})}});DB.run(sql,params.data,err=>{if(err){Logger.error("Message update:messages",err.message,{message:message,sql:sql,data:params.data})}resolve()})})};let getList=({conversation})=>{let{time,order,count,names,conversationType,conversationId}=conversation;let symbol="<";let direction="ASC";let _time=utils.isEqual(time,0)?Date.now():time;if(utils.isEqual(MESSAGE_ORDER.FORWARD,order)){symbol=">";_time=time;direction="DESC"}let wheres=[`sentTime ${symbol} ${_time}`,`conversationType = ${conversationType}`,`conversationId = '${conversationId}'`];if(!utils.isEmpty(names)){wheres.push(`name in ('${names.join("','")}')`)}let tpl=`FROM messages WHERE ${wheres.join(" AND ")} ORDER BY sentTime ${direction} LIMIT ${count}`;let rowsSQL=`SELECT * ${tpl}`;let totalSQL=`SELECT COUNT(*) as total ${tpl}`;return utils.deferred((resolve,reject)=>{let isFinished=false;let groups=[],senders=[],messages=[];let rowPromise=utils.deferred((_resolve,_reject)=>{DB.all(rowsSQL,[],(err,rows)=>{if(err){Logger.error("Message getList:rows",err.message,{sql:rowsSQL})}messages=rows;let _groups=[],_senders=[];if(common.isGroup(conversationType)){_groups.push({id:conversationId})}_senders=utils.duplicate(rows,row=>{return row.senderId});_senders=utils.map(_senders,sender=>{return{id:sender.senderId}});let p1=$user.get(_senders).then(result=>{senders=result;return result});let p2=$group.get(_groups).then(result=>{groups=result;return result});Promise.all([p1,p2]).then(()=>{_resolve()})})});let totalPromise=utils.deferred((_resolve,_reject)=>{DB.all(totalSQL,[],(err,rows)=>{if(err){Logger.error("Message getList:total",err.message,{sql:totalSQL})}isFinished=count>rows[0].total;_resolve()})});Promise.all([rowPromise,totalPromise]).then(()=>{resolve({isFinished:isFinished,messages:messages,groups:groups,senders:senders})})})};let upsert=({messages})=>{let messageIds=[];utils.forEach(messages,message=>{messageIds.push(message.messageId)});let sql=`DELETE FROM messages WHERE messageId in ('${messageIds.join("','")}')`;DB.serialize(()=>{DB.run(sql);insert({messages:messages})})};let recall=({message,name})=>{let{messageId}=message;let msg={messageId:messageId,name:name,content:message};return update({message:msg})};let clear=({params})=>{let{conversationType,conversationId,time}=params;return utils.deferred(resolve=>{let sql=`DELETE FROM messages 
                WHERE conversationType = ${conversationType} AND 
                conversationId = '${conversationId}' AND 
                sentTime <= ${time};`;DB.run(sql,{},err=>{if(err){Logger.error("Message clear",err.message,{sql:sql})}resolve()})})};let read=({messages})=>{let list=utils.isArray(messages)?messages:[messages];let messageIds=utils.map(list,item=>{return item.messageId});let mSQL=`UPDATE messages SET isRead = 1 WHERE messageId in ('${messageIds.join("','")}')`;let cSQL=`UPDATE conversations SET latestMessageIsRead = 1 WHERE latestMessageId in ('${messageIds.join("','")}')`;return utils.deferred(resolve=>{let p1=utils.deferred(_resolve=>{DB.run(mSQL,{},err=>{if(err){Logger.error("Message read:messages",err.message,{sql:mSQL})}_resolve()})});let p2=utils.deferred(_resolve=>{DB.run(cSQL,{},err=>{if(err){Logger.error("Message read:conversations",err.message,{sql:cSQL})}_resolve()})});Promise.all([p1,p2]).then(resolve)})};let get=({message})=>{let sql=`SELECT * FROM messages WHERE messageId = '${message.messageId}';`;return utils.deferred(resolve=>{DB.get(sql,{},(err,msg)=>{if(err){Logger.error("Message read",err.message,{sql:sql})}msg=msg||message;resolve(msg)})})};return{insert:insert,update:update,getList:getList,upsert:upsert,recall:recall,clear:clear,read:read,get:get}}var message$1=Message$1;const{app,ipcMain}=require$$0$1;const{INVOKE}=enmu;const JGDB=database;const Conversation=conversation;const Message=message$1;const User=user;function init(options={}){let $database={};let $message={};let $conversation={};let $user={};ipcMain.handle(INVOKE.SOCKET.OPEN_DB,(event,args)=>{let{dbpath}=options;let{appkey,user}=args;$database=JGDB.init({appkey:appkey,userId:user.userId,dbpath:dbpath});$message=Message($database);$conversation=Conversation($database);$user=User($database);return{isOpen:true}});ipcMain.handle(INVOKE.SOCKET.DISCONNECT,(event,args)=>{$database.close();return{}});ipcMain.handle(INVOKE.USER.INSERT,(event,args)=>{$user.upsert(args.user);return{}});ipcMain.handle(INVOKE.MESSAGE.INSERT,(event,args)=>{return $message.insert(args)});ipcMain.handle(INVOKE.MESSAGE.UPDATE,(event,args)=>{return $message.update(args)});ipcMain.handle(INVOKE.MESSAGE.GETLIST,(event,args)=>{return $message.getList(args)});ipcMain.handle(INVOKE.MESSAGE.UPSERT,(event,args)=>{return $message.upsert(args)});ipcMain.handle(INVOKE.MESSAGE.RECALL,(event,args)=>{return $message.recall(args)});ipcMain.handle(INVOKE.MESSAGE.CLEAR,(event,args)=>{return $message.clear(args)});ipcMain.handle(INVOKE.MESSAGE.READ,(event,args)=>{return $message.read(args)});ipcMain.handle(INVOKE.MESSAGE.GETONE,(event,args)=>{return $message.get(args)});ipcMain.handle(INVOKE.CONVERSATION.LIST,(event,args)=>{return $conversation.getList(args)});ipcMain.handle(INVOKE.CONVERSATION.UPSERT,(event,args)=>{return $conversation.upsert(args)});ipcMain.handle(INVOKE.CONVERSATION.UPDATE,(event,args)=>{return $conversation.update(args)});ipcMain.handle(INVOKE.CONVERSATION.CLEAR_UNREAD,(event,args)=>{return $conversation.clearUnread(args)});ipcMain.handle(INVOKE.CONVERSATION.GETONE,(event,args)=>{return $conversation.get(args)});ipcMain.handle(INVOKE.CONVERSATION.REMOVE,(event,args)=>{return $conversation.remove(args)});ipcMain.handle(INVOKE.CONVERSATION.GET_TOTAL_UNREAD,(event,args)=>{return $conversation.getTotalUnread(args)});ipcMain.handle(INVOKE.CONVERSATION.CLEAR_TOTAL_UNREAD,(event,args)=>{return $conversation.clearTotalUnread(args)})}var main={init:init};var main$1=getDefaultExportFromCjs(main);module.exports=main$1;